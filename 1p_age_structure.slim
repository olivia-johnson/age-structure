initialize() {
	defineConstant("outpath", "~/Documents/yuseob/");
	
	initializeSLiMModelType("nonWF"); // Non Wright-Fisher model
	
	defineConstant("K0", 5000);	// initial carrying capacity
	
	defineConstant("el", 0.7);	// probablility to advance from larvae to subadult
	
	defineConstant("es", 0.7);	// probablility to advance from subadult to adult
	
	defineConstant("J",8); // number of linked loci
	
	defineConstant("u", 5e-5); // mutation rate
	
	defineConstant("c", 0.02); // recombination probability among adults and subadults
	
	defineConstant("al", 0.25);
	
	defineConstant("bl", 0.1);
	
	if (!exists("as"))
	{defineConstant("as", 0.25);}
	
	if (!exists("bs"))
	{defineConstant("bs", 0.05);}
	
	defineConstant("age_transitions", c(1.0,el, es, 0.0, 0.0));
	
	initializeMutationType("m2", 0.5, "f", 0.0); // A2 mutation
	m2.convertToSubstitution = F;
	m2.color = "cornflowerblue";
	
	initializeMutationType("m3", 0.5, "f", 0.0); // Used for new mutations to enable backmutation
	m3.convertToSubstitution = F;
	m3.color = "red";
	initializeGenomicElementType("g1", m3, 1.0);
	
	initializeGenomicElement(g1, 0, J-1);
	initializeMutationRate(u);
	initializeRecombinationRate(c);
}

// each individual reproduces itself once
reproduction() {
	
	if (individual.age > 1 & individual.age < 4){
		i_age=individual.age;
		mate = subpop.sampleIndividuals(1, minAge=i_age, maxAge =i_age);
		subpop.addCrossed(individual, mate);}

}


mutation(m3) {
	// if we already have an m2 mutation at the site, allow
	// the new m3 mutation; we will remove the stack below (A2 back to A1)
	if (genome.containsMarkerMutation(m2, mut.position))
		return T;
	// no m2 mutation is present, so unique down
	return MUT[mut.position];
}


1 first(){//draw in single subpopulation
	defineGlobal("Z3j", rnorm(J)); // define Z1 and Z2 current generation
	
	defineGlobal("Z", rnorm(2)); // define Z1 and Z2 current generation
	defineGlobal("Kt2", asInteger(es*el*K0*exp((al*Z[0])+(bl*Z[1])))); // define Kt-2
	defineGlobal("Kt1", asInteger(el*K0*exp((al*Z[0])+(bl*Z[1])))); // define Kt-1
	defineGlobal("Kt", asInteger(K0*exp((al*Z[0])+(bl*Z[1])))); // define Kt
	defineGlobal("N", asInteger(K0+round(K0*el)+round(K0*el*es)));
	defineGlobal("colours", c(0,"pink", "yellow", "blue", "black")); // define age colours
	
	sim.addSubpop("p1", N);
	
	ages=c(repEach(1, K0), repEach(2, asInteger(round(K0*el))), repEach(3,asInteger(round(K0*el*es))));
	
	rAges=sample(ages, N);
	
	p1.individuals.age=rAges;
	
	for (i in c(1,2,3))
	{
		p1.individuals[p1.individuals.age==i].color=colours[i];
	}
	header="Time,mut_id,mut_pos,af";
	writeFile(paste0(outpath, "af_",as,"_",bs,".txt"), header,append=F);
	
	// create mutation objects for back mutation
	target = p1.genomes[0];
	target.addNewDrawnMutation(m2, 0:(J-1));
	defineConstant("MUT", target.mutations);
	// then remove them; start with "A1" for all individuals
	target.removeMutations();
}

// fitness effect
fitnessEffect() {
	if (individual.age>1){
		gm=individual.genomes.mutationsOfType(m2).position;
		if (length(gm)>0){
			gm1=individual.genome1.mutationsOfType(m2).position;
			gm2=individual.genome2.mutationsOfType(m2).position;
			if ((length(gm1)>0&length(gm2)==0)|(length(gm2)>0&length(gm1)==0)){
				Sjt=1+Z3j[gm]*bs+(as*Z[0]);
				wit=product(Sjt);
				return 1+wit;
			
			}else{
				//				vec=c(rep(1.0, J));
				//				vec[gm1]=((vec[gm1]+Z3j[gm1])*bs)+(as*Z[0]);
				//				vec[gm2]=((vec[gm2]+Z3j[gm2])*bs)+(as*Z[0]);
				//				vec[unique(gm)]=1+vec[unique(gm)];
				//				Sjt=vec[vec!=1.0];
				//
				//				
				//				wit=product(Sjt);
				
				
				Sjt1=1+Z3j[gm1]*bs+(as*Z[0]);
				
				Sjt2=1+Z3j[gm2]*bs+(as*Z[0]);
				
				wit=product(Sjt1)+product(Sjt2);
				return 1+wit;}
		}else{
			return 1.0;
		}
	} else{
		return 1.0;}
}

2: early() {
	defineGlobal("Z", rnorm(2)); // define Z1 and Z2 current generation
	defineGlobal("Kt2", asInteger(el*es*Kt1)); // define Kt
	defineGlobal("Kt1", asInteger(el*Kt)); // define Kt
	defineGlobal("Kt", asInteger(K0*exp((al*Z[0])+(bl*Z[1])))); // define Kt
	
	
	
	
	for (i in c(1,2,3))
	{
		p1.individuals[p1.individuals.age==i].color=colours[i];
	
	}
	if (length(p1.individuals[p1.individuals.age>3])>0){
		p1.individuals[p1.individuals.age>3].color="black";
	}
}

// provide density-dependent selection
early() {
	
	defineGlobal("Z3j", rnorm(J)); // define Z1 and Z2 current generation
	
	
	defineGlobal("K", c(0, Kt, Kt1, Kt2,0));
	gerries=p1.individuals[p1.individuals.age>3];
	sim.killIndividuals(gerries);
	
	
	for (i in 1:3)
	{
		inds=p1.individuals[p1.individuals.age==i];
		inds.fitnessScaling = K[i]/length(inds) ;
	}
}

late() {
	// implement back-mutations from A2 to A1
	m3muts = sim.mutationsOfType(m3);
	// do we have any m3 mutations segregating?
	// if so, we have m2/m3 stacked mutations to remove
	if (m3muts.length() > 0)
	{
		genomes = sim.subpopulations.genomes;
		counts = genomes.countOfMutationsOfType(m3);
		hasStacked = genomes[counts > 0];
		for (genome in hasStacked)
		{
			stacked_m3 = genome.mutationsOfType(m3);
			stackPositions = stacked_m3.position;
			all_m2 = genome.mutationsOfType(m2);
			s = (match(all_m2.position, stackPositions) >= 0);
			stacked_m2 = all_m2[s];
			genome.removeMutations(c(stacked_m3, stacked_m2));
		}
	}
	
	if (exists("slimgui")) {catn(paste("N by age 1=", length(p1.individuals[p1.individuals.age==1]), ", 2=", length(p1.individuals[p1.individuals.age==2]), ", 3=",length(p1.individuals[p1.individuals.age==3]), ", >4=", length(p1.individuals[p1.individuals.age>3])));}
	
	if (size(sim.mutations)>0){
		for (i in 1:size(sim.mutations)-1){
			tab_line = paste(c(sim.cycle,sim.mutations[i].id,sim.mutations[i].position,sim.mutationFrequencies(p1)[i]), sep = ",");
			writeFile(paste0(outpath, "af_",as,"_",bs,".txt"), tab_line, append = T);
		} }
}


// output all fixed mutations at end
20000 late() {
}
