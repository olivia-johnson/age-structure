initialize() {
	defineConstant("outpath", "~/Documents/yuseob/");
	
	initializeSLiMModelType("nonWF"); // Non Wright-Fisher model
	
	defineConstant("K0", 5000);	// initial carrying capacity
	
	defineConstant("el", 0.7);	// probablility to advance from larva to subadult
	
	defineConstant("es", 0.7);	// probablility to advance from subadult to adult
	
	defineConstant("J",8); // number of loci
	
	defineConstant("u", 5e-5); // mutation rate
	
	defineConstant("c", 0.02); // recombination prate
	
	defineConstant("al", 0.25);
	
	defineConstant("bl", 0.1);
	
	if (!exists("as"))
	{defineConstant("as", 0.25);}
	
	if (!exists("bs"))
	{defineConstant("bs", 0.05);}
	
	if (!exists("filename"))
	{defineConstant("filename", "fits_test");}
	
	defineConstant("age_transitions", c(1.0,el, es, 0.0, 0.0)); //probability of surviving from one stage to the next
	
	initializeMutationType("m2", 0.5, "f", 0.0); // A2 mutation
	m2.convertToSubstitution = F;
	m2.color = "cornflowerblue";
	
	initializeMutationType("m3", 0.5, "f", 0.0); // Used for new mutations to enable backmutation
	m3.convertToSubstitution = F;
	m3.color = "red";
	initializeGenomicElementType("g1", m3, 1.0);
	
	initializeGenomicElement(g1, 0, J-1);
	initializeMutationRate(u);
	initializeRecombinationRate(c);
}

// individuals reproduce with others of the same age and only in older than 1 (larva age)
reproduction() {
	
	if (individual.age > 1 & individual.age < 4){
		i_age=individual.age;
	
		gt=paste0(individual.genomes.mutationCountsInGenomes(sim.mutations));
		sub=which(ug==gt);
		n_child=rpois(1,ih[sub]);
		mate = subpop.sampleIndividuals(1, minAge=i_age, maxAge =i_age);
		subpop.addCrossed(individual, mate, count=n_child);}
//		subpop.addCrossed(individual, mate);}

}


mutation(m3) {
	// if we already have an m2 mutation at the site, allow
	// the new m3 mutation; we will remove the stack below (A2 back to A1)
	if (genome.containsMarkerMutation(m2, mut.position))
		return T;
	// no m2 mutation is present, so unique down
	return MUT[mut.position];
}


1 first(){// draw parmeters
	defineGlobal("Z3j", rnorm(J)); // define Z3j for loci
	defineGlobal("Z", rnorm(2)); // define Z1 and Z2 current generation
	defineGlobal("Kt2", asInteger(es*el*K0*exp((al*Z[0])+(bl*Z[1])))); // define initial Kt-2 using K0
	defineGlobal("Kt1", asInteger(el*K0*exp((al*Z[0])+(bl*Z[1])))); // define initial Kt-1 using K0
	defineGlobal("Kt", asInteger(K0*exp((al*Z[0])+(bl*Z[1])))); // define initial Kt using K0
	defineGlobal("N", asInteger(K0+round(K0*el)+round(K0*el*es))); // combine Kt, Kt-1 and Kt-2 to get total number of idndividuals in intial population
	defineGlobal("colours", c(0,"pink", "yellow", "blue", "black")); // define age colours
	
	sim.addSubpop("p1", N); // create population
	
	ages=c(repEach(1, K0), repEach(2, asInteger(round(K0*el))), repEach(3,asInteger(round(K0*el*es)))); //create a vector of ages based on abouve values
	
	rAges=sample(ages, N); // randomly sample all individuals so ages are random
	
	p1.individuals.age=rAges; // assign ages
	
	for (i in c(1,2,3)) // add colour to individuals so ages can be visualised in gui
	{
		p1.individuals[p1.individuals.age==i].color=colours[i];
	}
	
	//create file to record allele frequencies
	header="Time,mut_id,mut_pos,af";
	writeFile(paste0(outpath, "af_", filename,".txt"), header,append=F);
	
	//create file to record population size and age sizes
	pheader="Time,N,larva,subadult,adult,Kt,Kt-1,Kt-2";
	writeFile(paste0(outpath, "pop_", filename,".txt"), pheader,append=F);
	
	// create mutation objects for back mutation
	target = p1.genomes[0];
	target.addNewDrawnMutation(m2, 0:(J-1));
	defineConstant("MUT", target.mutations);
	// then remove them; start with "A1" for all individuals
	target.removeMutations();
}

first(){
for (ind in p1.individuals){  // loop through individuals
		if (ind.age>1){ // if individual is older than 1 (past larva stage)
			
			
			/// genotype fitness considered like a single haploid 
			gm=ind.genomes.mutationsOfType(m2).position; // get positions of A2 mutations
			Wit=product(1+((Z3j[gm]*bs)+(as*Z[0]))); // product of relative fitness of each locus across genotype
			
			/// gentoype fitness considered as two haplotypes with Wit either added or mulitplied
			//						gm1=ind.genome1.mutationsOfType(m2).position;
			//						gm2=ind.genome2.mutationsOfType(m2).position;
			//						Sjt1=1+Z3j[gm1]*bs+(as*Z[0]);
			//						
			//						Sjt2=1+Z3j[gm2]*bs+(as*Z[0]);
			//						
			//						Wit=product(Sjt1)+product(Sjt2);
			
			/// vectored fitness where Z3j scores are mulitples before included in Sjt
			//			gm1=ind.genome1.mutationsOfType(m2).position;
			//			gm2=ind.genome2.mutationsOfType(m2).position;
			//			gm=c(rep(1.0, J));
			//			gm[gm1]=gm[gm1]*Z3j[gm1];
			//			gm[gm2]=gm[gm2]*Z3j[gm2];
			//			Sjt=gm[gm!=1.0];
			//			Wit=product(1+((Sjt*bs)+(as*Z[0]))); // product of relative fitness of each locus across genotype
			
			ind.tagF=Wit; // tage individuals with their genotype fitness
		} else{
			ind.tagF=1.0; // if individual is in larva stage return genotype fitness as 1
		}
	
	}
	geno=c();
	fit=c();
	for (g in 0:(length(p1.individuals)-1)){
		if (p1.individuals[g].age>1 & p1.individuals[g].age<4){
			geno=c(geno, paste0(p1.individuals[g].genomes.mutationCountsInGenomes(sim.mutations)));
			fit=c(fit,p1.individuals[g].tagF);
		}}
	
	defineGlobal("geno",unique(geno));
	defineGlobal("fit", unique(fit));
	
	denom=c();
	ih=c();
	for (g in 1:length(unique(geno))-1){
		genotype=unique(geno)[g];
		fitness=unique(fit)[g];
		gf=length(which(geno==genotype));
		denom=c(denom,gf*fitness);
		ihg = rpois(1,((length(which(geno==unique(geno)[g]))*unique(fit)[g]*Kt)/sum(denom)))/(length(which(geno==unique(geno)[g])));
		ih=c(ih, ihg);
	}
	
	defineGlobal("ug",unique(geno));
	defineGlobal("ih", ih);
	defineGlobal("denom", denom);


}

2: early() {
	defineGlobal("Z", rnorm(2)); // define Z1 and Z2 current generation
	defineGlobal("Z3j", rnorm(J)); // define Z3j for current generation
	defineGlobal("Kt2", asInteger(es*Kt1)); // define Kt-2 as Kt-1 from previous generation
	defineGlobal("Kt1", asInteger(el*Kt)); // define Kt-1 as Kt from previous generation
	defineGlobal("Kt", asInteger(K0*exp((al*Z[0])+(bl*Z[1])))); // define Kt
	
	for (i in c(1,2,3)) // reseat age colours
	{
		p1.individuals[p1.individuals.age==i].color=colours[i];
	
	}
	if (length(p1.individuals[p1.individuals.age>3])>0){
		p1.individuals[p1.individuals.age>3].color="black";
	}
}

early() {
	// implement back-mutations from A2 to A1
	m3muts = sim.mutationsOfType(m3);
	// do we have any m3 mutations segregating?
	// if so, we have m2/m3 stacked mutations to remove
	if (m3muts.length() > 0)
	{
		genomes = sim.subpopulations.genomes;
		counts = genomes.countOfMutationsOfType(m3);
		hasStacked = genomes[counts > 0];
		for (genome in hasStacked)
		{
			stacked_m3 = genome.mutationsOfType(m3);
			stackPositions = stacked_m3.position;
			all_m2 = genome.mutationsOfType(m2);
			s = (match(all_m2.position, stackPositions) >= 0);
			stacked_m2 = all_m2[s];
			genome.removeMutations(c(stacked_m3, stacked_m2));
		}
	}
	
	defineGlobal("K", c(0, Kt, Kt1, Kt2,0)); // make vector of ccarrying capacities
	gerries=p1.individuals[p1.individuals.age>3]; // identify individuals over age 3 (adult)
	sim.killIndividuals(gerries); // remove them from population
	
	// calculate genotype fitness
	
	
	//age based density dependence and implementation of selection
	for (i in 1:3) // enforce carrying capacities for each age
	{
		inds=p1.individuals[p1.individuals.age==i]; // vector of individuals of given age (larva/subadult/adult)
		indfit= inds.tagF* (K[i]/length(inds)) ; //determine fitness as the genotype fitness * density dependence relative to age based carrying capacity
		inds.fitnessScaling=indfit; // apply fitness scailing to individuals
	}



}

late() {
	
	
	if (exists("slimgui")) {catn(paste("N by age 1=", Kt-length(p1.individuals[p1.individuals.age==1]), ", 2=", Kt1-length(p1.individuals[p1.individuals.age==2]), ", 3=",Kt2-length(p1.individuals[p1.individuals.age==3]), ", >4=", length(p1.individuals[p1.individuals.age>3])));}//, "\n Kt=", Kt, ", Kt-1=", Kt1, ", Kt-2 =", Kt2));}
	
	if (size(sim.mutations)>0){
		for (i in 1:size(sim.mutations)-1){
			tab_line = paste(c(sim.cycle,sim.mutations[i].id,sim.mutations[i].position,sim.mutationFrequencies(p1)[i]), sep = ",");
			writeFile(paste0(outpath, "af_", filename,".txt"), tab_line, append = T);
		} }
	
	ptab_line = paste(c(sim.cycle,p1.individualCount,size(p1.individuals[p1.individuals.age==1]), size(p1.individuals[p1.individuals.age==2]),size(p1.individuals[p1.individuals.age==3]), Kt, Kt1, Kt2), sep = ",");
	writeFile(paste0(outpath, "pop_", filename,".txt"), ptab_line, append = T);


}


// output all fixed mutations at end
20000 late() {
}
