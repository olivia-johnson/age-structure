initialize() {
	initializeSLiMModelType("nonWF"); // Non Wright-Fisher model
	
	defineConstant("K0", 5000);	// initial carrying capacity
	
	defineConstant("el", 0.7);	// probablility to advabce from larvae to subadult
	
	defineConstant("es", 0.7);	// probablility to advabce from subadult to adult
	
	defineConstant("J",8); // number of linked loci
	
	defineConstant("u", 5e-5); // mutation rate
	
	defineConstant("c", 0.02); // recombination probability among adults and subadults
	
	defineConstant("al", 0.25);
	
	defineConstant("bl", 0.1);
	
	if (!exists("as"))
	{defineConstant("as", 0.1);}
	
	if (!exists("bs"))
	{defineConstant("bs", 0.2);}
	
	defineConstant("age_transitions", c(el, es, 1.0));
	
	initializeMutationType("m1", 0.5, "f", 0.0);
	m1.convertToSubstitution = F;
	
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, J);
	initializeMutationRate(u);
	initializeRecombinationRate(c);
}

// each individual reproduces itself once
reproduction() {
	subpop.addCrossed(individual, subpop.sampleIndividuals(1));
}

2: early() {
	defineGlobal("Z", rnorm(2)); // define Z1 and Z2 current generation
	
	defineGlobal("Kt", K0*exp((al*Z[0])+(bl*Z[1]))); // define Kt
	
	for (i in c(0,1,2))
	{
		p1.individuals[p1.individuals.age==i].color=colours[i];
	
	}}

1 early(){//draw in single subpopulation
	
	defineGlobal("Z", rnorm(2)); // define Z1 and Z2 current generation
	defineGlobal("Kt2", asInteger(es*el*K0*exp((al*Z[0])+(bl*Z[1])))); // define Kt-2
	defineGlobal("Kt1", asInteger(el*K0*exp((al*Z[0])+(bl*Z[1])))); // define Kt-1
	defineGlobal("Kt", asInteger(K0*exp((al*Z[0])+(bl*Z[1])))); // define Kt
	defineGlobal("N", asInteger(K0+(K0*el)+(K0*el*es)));
	defineGlobal("colours", c("pink", "yellow", "blue")); // define Kt
	
	sim.addSubpop("p1", N, haploid=T);
	
	ages=c(repEach(0, K0), repEach(1, asInteger(K0*el)), repEach(2,asInteger(K0*el*es)));
	
	rAges=sample(ages, N);
	
	p1.individuals.age=rAges;
	
	for (i in c(0,1,2))
	{
		p1.individuals[p1.individuals.age==i].color=colours[i];
	
	}

}


 // provide density-dependent selection
early() {
	// life table based individual mortality
	inds = p1.individuals;
	ages = inds.age;
	survival = age_transitions[ages];
	inds.fitnessScaling = survival;
	// density-dependence, factoring in individual mortality
//	p1.fitnessScaling = K / (p1.individualCount * mean(survival));
}

// output all fixed mutations at end
2000 late() { sim.outputFixedMutations(); }
